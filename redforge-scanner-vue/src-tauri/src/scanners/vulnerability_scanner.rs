use crate::models::*;
use crate::scanners::ScannerResult;
use reqwest::Client;
use uuid::Uuid;
use chrono::Utc;

pub struct VulnerabilityScanner {
    client: Client,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            client: Client::builder()
                .danger_accept_invalid_certs(true)
                .timeout(std::time::Duration::from_secs(15))
                .redirect(reqwest::redirect::Policy::limited(5))
                .build()
                .unwrap(),
        }
    }

    /// 執行完整的 OWASP Top 10 掃描
    pub async fn scan(&self, task_id: &str, url: &str) -> ScannerResult<Vec<ScanResult>> {
        let mut results = Vec::new();

        // 1. 注入攻擊檢測（SQL, XSS, Command）
        results.extend(self.check_injection_flaws(task_id, url).await?);

        // 2. 安全配置錯誤
        results.extend(self.check_security_misconfig(task_id, url).await?);

        // 3. 敏感資料洩露
        results.extend(self.check_sensitive_data_exposure(task_id, url).await?);

        // 4. 不安全的反序列化
        results.extend(self.check_deserialization(task_id, url).await?);

        // 5. 使用含有已知漏洞的組件
        results.extend(self.check_vulnerable_components(task_id, url).await?);

        Ok(results)
    }

    /// 檢查注入漏洞（SQL Injection, XSS）
    async fn check_injection_flaws(&self, task_id: &str, base_url: &str) -> ScannerResult<Vec<ScanResult>> {
        let mut results = Vec::new();

        // SQL Injection payloads
        let sql_payloads = vec![
            "' OR '1'='1",
            "' OR '1'='1' --",
            "1' OR '1' = '1",
            "admin'--",
            "' UNION SELECT NULL--",
        ];

        for payload in sql_payloads {
            // 測試 URL 參數注入
            let test_url = format!("{}?id={}", base_url, urlencoding::encode(payload));

            match self.client.get(&test_url).send().await {
                Ok(response) => {
                    let body = response.text().await.unwrap_or_default();

                    // 檢查常見的 SQL 錯誤訊息
                    let sql_errors = vec![
                        "sql syntax", "mysql", "postgresql", "sqlite", "syntax error",
                        "odbc", "jdbc", "oracle", "warning: mysql"
                    ];

                    if sql_errors.iter().any(|err| body.to_lowercase().contains(err)) {
                        results.push(ScanResult {
                            id: Uuid::new_v4().to_string(),
                            task_id: task_id.to_string(),
                            result_type: ResultType::Vulnerability,
                            severity: Some(Severity::High),
                            title: "潛在的 SQL Injection 漏洞".to_string(),
                            description: Some(format!(
                                "使用 payload '{}' 觸發了資料庫錯誤訊息，可能存在 SQL 注入漏洞",
                                payload
                            )),
                            raw_data: Some(serde_json::to_string(&serde_json::json!({
                                "payload": payload,
                                "url": test_url,
                                "error_indicators": sql_errors
                            })).unwrap()),
                            created_at: Utc::now(),
                        });
                        break; // 找到一個就足夠
                    }
                },
                Err(_) => continue,
            }
        }

        // XSS 檢測
        let xss_payloads = vec![
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
        ];

        for payload in xss_payloads {
            let test_url = format!("{}?q={}", base_url, urlencoding::encode(payload));

            match self.client.get(&test_url).send().await {
                Ok(response) => {
                    let body = response.text().await.unwrap_or_default();

                    // 檢查 payload 是否未經編碼直接出現在響應中
                    if body.contains(payload) || body.contains(&payload.replace("'", "\"")) {
                        results.push(ScanResult {
                            id: Uuid::new_v4().to_string(),
                            task_id: task_id.to_string(),
                            result_type: ResultType::Vulnerability,
                            severity: Some(Severity::High),
                            title: "潛在的 XSS (跨站腳本) 漏洞".to_string(),
                            description: Some(format!(
                                "輸入內容未正確編碼就輸出到 HTML 中，可能存在 XSS 漏洞"
                            )),
                            raw_data: Some(serde_json::to_string(&serde_json::json!({
                                "payload": payload,
                                "url": test_url,
                                "reflected": true
                            })).unwrap()),
                            created_at: Utc::now(),
                        });
                        break;
                    }
                },
                Err(_) => continue,
            }
        }

        Ok(results)
    }

    /// 檢查安全配置錯誤
    async fn check_security_misconfig(&self, task_id: &str, base_url: &str) -> ScannerResult<Vec<ScanResult>> {
        let mut results = Vec::new();

        // 檢查常見的敏感文件
        let sensitive_paths = vec![
            "/.git/config",
            "/.env",
            "/config.php",
            "/wp-config.php",
            "/.htaccess",
            "/phpinfo.php",
            "/admin",
            "/backup.sql",
            "/database.sql",
            "/.DS_Store",
        ];

        for path in sensitive_paths {
            let test_url = format!("{}{}", base_url.trim_end_matches('/'), path);

            match self.client.get(&test_url).send().await {
                Ok(response) => {
                    if response.status().is_success() {
                        let severity = if path.contains(".env") || path.contains("config") {
                            Severity::Critical
                        } else if path.contains(".git") {
                            Severity::High
                        } else {
                            Severity::Medium
                        };

                        results.push(ScanResult {
                            id: Uuid::new_v4().to_string(),
                            task_id: task_id.to_string(),
                            result_type: ResultType::Vulnerability,
                            severity: Some(severity),
                            title: format!("發現可訪問的敏感文件: {}", path),
                            description: Some(format!(
                                "敏感文件 {} 可以被公開訪問，這可能洩露重要的配置資訊或原始碼",
                                path
                            )),
                            raw_data: Some(serde_json::to_string(&serde_json::json!({
                                "path": path,
                                "url": test_url,
                                "status": response.status().as_u16()
                            })).unwrap()),
                            created_at: Utc::now(),
                        });
                    }
                },
                Err(_) => continue,
            }
        }

        // 檢查目錄列表
        let dir_paths = vec!["/uploads", "/images", "/static", "/assets", "/backup"];
        for path in dir_paths {
            let test_url = format!("{}{}", base_url.trim_end_matches('/'), path);

            match self.client.get(&test_url).send().await {
                Ok(response) => {
                    let body = response.text().await.unwrap_or_default();

                    // 檢查是否為目錄列表頁面
                    if body.contains("Index of") || body.contains("Directory listing") {
                        results.push(ScanResult {
                            id: Uuid::new_v4().to_string(),
                            task_id: task_id.to_string(),
                            result_type: ResultType::Vulnerability,
                            severity: Some(Severity::Medium),
                            title: format!("發現目錄列表: {}", path),
                            description: Some(format!(
                                "目錄 {} 啟用了目錄列表功能，可能洩露文件結構資訊",
                                path
                            )),
                            raw_data: Some(serde_json::to_string(&serde_json::json!({
                                "path": path,
                                "url": test_url
                            })).unwrap()),
                            created_at: Utc::now(),
                        });
                    }
                },
                Err(_) => continue,
            }
        }

        Ok(results)
    }

    /// 檢查敏感資料洩露
    async fn check_sensitive_data_exposure(&self, task_id: &str, base_url: &str) -> ScannerResult<Vec<ScanResult>> {
        let mut results = Vec::new();

        // 檢查是否使用 HTTPS
        if !base_url.starts_with("https://") {
            results.push(ScanResult {
                id: Uuid::new_v4().to_string(),
                task_id: task_id.to_string(),
                result_type: ResultType::Vulnerability,
                severity: Some(Severity::High),
                title: "未使用 HTTPS 加密傳輸".to_string(),
                description: Some(
                    "網站未使用 HTTPS，所有傳輸資料（包括密碼、個人資訊）都可能被中間人攔截".to_string()
                ),
                raw_data: Some(serde_json::to_string(&serde_json::json!({
                    "url": base_url,
                    "protocol": "http"
                })).unwrap()),
                created_at: Utc::now(),
            });
        }

        // 檢查原始碼中的敏感資訊
        match self.client.get(base_url).send().await {
            Ok(response) => {
                let body = response.text().await.unwrap_or_default();

                // 檢查 API keys, tokens
                let patterns = vec![
                    (r#"api[_-]?key['\"]?\s*[:=]\s*['\"]([a-zA-Z0-9]{20,})"#, "API Key"),
                    (r#"access[_-]?token['\"]?\s*[:=]\s*['\"]([a-zA-Z0-9]{20,})"#, "Access Token"),
                    (r#"password['\"]?\s*[:=]\s*['\"]([^'\"]{3,})"#, "密碼"),
                ];

                for (pattern, name) in patterns {
                    if let Ok(re) = regex::Regex::new(pattern) {
                        if re.is_match(&body) {
                            results.push(ScanResult {
                                id: Uuid::new_v4().to_string(),
                                task_id: task_id.to_string(),
                                result_type: ResultType::Vulnerability,
                                severity: Some(Severity::Critical),
                                title: format!("HTML 原始碼中發現 {}", name),
                                description: Some(format!(
                                    "網頁原始碼中包含 {}，這可能導致敏感資訊洩露",
                                    name
                                )),
                                raw_data: Some(serde_json::to_string(&serde_json::json!({
                                    "type": name,
                                    "pattern": pattern
                                })).unwrap()),
                                created_at: Utc::now(),
                            });
                        }
                    }
                }
            },
            Err(_) => {},
        }

        Ok(results)
    }

    /// 檢查不安全的反序列化
    async fn check_deserialization(&self, task_id: &str, base_url: &str) -> ScannerResult<Vec<ScanResult>> {
        let mut results = Vec::new();

        // 檢查 cookies 中是否包含序列化資料
        match self.client.get(base_url).send().await {
            Ok(response) => {
                for cookie in response.cookies() {
                    let value = cookie.value();

                    // 檢查是否為 base64 編碼的序列化資料
                    if value.len() > 50 && (value.starts_with("O:") || value.starts_with("rO0")) {
                        results.push(ScanResult {
                            id: Uuid::new_v4().to_string(),
                            task_id: task_id.to_string(),
                            result_type: ResultType::Vulnerability,
                            severity: Some(Severity::Medium),
                            title: "Cookie 中發現序列化資料".to_string(),
                            description: Some(
                                "Cookie 中包含序列化物件，如果未正確驗證可能導致遠程代碼執行".to_string()
                            ),
                            raw_data: Some(serde_json::to_string(&serde_json::json!({
                                "cookie_name": cookie.name(),
                                "value_prefix": &value[..20.min(value.len())]
                            })).unwrap()),
                            created_at: Utc::now(),
                        });
                    }
                }
            },
            Err(_) => {},
        }

        Ok(results)
    }

    /// 檢查使用含有已知漏洞的組件
    async fn check_vulnerable_components(&self, task_id: &str, base_url: &str) -> ScannerResult<Vec<ScanResult>> {
        let mut results = Vec::new();

        match self.client.get(base_url).send().await {
            Ok(response) => {
                let body = response.text().await.unwrap_or_default();

                // 檢查已知的過時庫
                let vulnerable_libs = vec![
                    ("jquery-1.", "jQuery 1.x", "已知多個 XSS 漏洞"),
                    ("jquery-2.", "jQuery 2.x", "已知安全問題"),
                    ("angular.js/1.0", "AngularJS 1.0", "已停止支援"),
                    ("bootstrap/3.", "Bootstrap 3", "已停止安全更新"),
                ];

                for (pattern, lib_name, issue) in vulnerable_libs {
                    if body.to_lowercase().contains(pattern) {
                        results.push(ScanResult {
                            id: Uuid::new_v4().to_string(),
                            task_id: task_id.to_string(),
                            result_type: ResultType::Vulnerability,
                            severity: Some(Severity::Medium),
                            title: format!("使用過時的組件: {}", lib_name),
                            description: Some(format!(
                                "檢測到使用 {}，{}。建議升級到最新版本",
                                lib_name, issue
                            )),
                            raw_data: Some(serde_json::to_string(&serde_json::json!({
                                "library": lib_name,
                                "pattern": pattern,
                                "issue": issue
                            })).unwrap()),
                            created_at: Utc::now(),
                        });
                    }
                }
            },
            Err(_) => {},
        }

        Ok(results)
    }
}
